libmach - short introduction
----------------------------

brief
-----

zero libmach is a collection of machine-dependent routines. these may be used
for things such as implementing [thread-safe] synchronization primitives.

usage
-----

#include <mach/asm.h> // machine interface

types
-----

the following are some basic <mach/types.h> types for machine-level programming.

machine types
-------------
m_reg_t		- signed word/register
m_adr_t         - storage for integer address value + possible info-bits
m_ptr_t         - pointer

<mach/asm.h> includes <mach/atomic.h> to define the following atomic types.

do not forget to declare in-memory data volatile where due.

atomic types
------------
m_atomic_t      - atomic machine register value/word
m_atomic8_t	- signed 8-bit atomic type
m_atomic16_t	- signed 16-bit atomic type
m_atomic32_t	- signed 32-bit atomic type
m_atomic64_t	- signed 64-bit atomic type
m_atomicptr_t	- atomic pointer storage type
m_atomicptr8_t	- atomic 8-bit pointer for arithmetics
m_atomicadr_t	- atomic integer address/pointer value for flag-bits

interface
---------

where not otherwise documented, all these operations perform atomically.

- m_membar() - full [read/write] memory barrier
  - synchronize pending mempry operations
- m_memddbar()  - data dependency barrier
  - synonymous with m_membar()
- m_memrdbar()  - read barrier
- m_memwrbar()  - write barrier
- m_waitspin()  - pause, wait, or loop (in spin-wait loops)
  - e.g. PAUSE on X86 to reduce power consumption of "busy-loops"
- m_endspin()   - exit spin-loop (where relevant, empty elsewhere)
  - signal end of wait (ARM SEV etc.) to wake threads up
- m_waitint()  	- pause until interrupt received
  - wake up after interrupt has been handled
- m_cmpswap()  	- atomic compare and swap operation
  - mutexes and such
- m_fetchadd()  - atomic fetch and add
  - reference counts
- m_getretadr() - get return address of current function
  - ABI interface

