V0 INSTRUCTION SET REFERENCE
----------------------------

This text describes the [draft version of the] V0 instruction set.

Instructions are represented as 32-bit parcels with an optional 32-bit immediate
argument parcel following them. The format of the instruction parcel is as
follows.

Opcode Structure
----------------

This structure is represented in C and is in little-endian byte order.

struct v0ins {
    unsigned	op	: 6;	// operation ID
    unsigned	unit	: 5;	// unit ID
    unsigned	flags	: 5;	// operation flags
    unsigned	reg1	: 7;	// register #1 ID
    unsigned	reg2	: 7;	// register #2 ID
    unsigned	adr	: 2;	// address type/mode
};

CODE-FIELD
----------

The code-field of an instruction consists of the instruction ID and flag-bits.
We reserve the low-most [first] 8 bits for instruction and unit IDs.

FLAGS-Bits
---------

These bits are located in the high bits [11:15] of the code-field of the
instruction.

Name	Description		Bit
----	-----------		---
ATOM    atomic operations	11
BYTE	byte-size operation	12
HALF	half-word operation	13
IMM	immediate argument	14
UNSG	unsigned operation	15

Register IDs
------------

Register #1 (source) ID is stored in the bits [0:6] of the parm-field of the
instruction, whereas register ID #2 (destination) is in the bits [7:13].

ADR-Bits
--------

These bits are the bits [14:15] in the parm-field of the instruction.

Value	Description
-----	-----------
00	no address; register arguments only
10	register address; base address in register
01	direct address; no base register (offset only)
11	indexed address; base register + offset (register or immediate)

Addressing Modes
----------------

Mode	Description		Brief
----	-----------		-----
N	no address		register operands only
R	register address	base address in register
O	offset			immediate offset or direct address

Addressing Examples
-------------------

Mode	Instruction		Comment				ADR-Bits
----	-----------		-------				--------
N	inc	%r1, %r2	; no address, registers only	00
R	jmp	*%r1 		; register address		10
RI	ldr	4(%sp), %r1	; register + offset		11
O	ldr	trapvec, %r1	; indexed/direct address	01

Opcode Format
-------------

NOTE that opcodes are represented in little-endian format, i.e. lowest-
significant bit/byte first.

Field		Description		Bits
-----		-----------		----
OP		operation ID		0:5
UNIT		unit ID	  		6:10
FLAGS		flag bits		11:15
REG1		argument 1		16:22
REG2		argument 2		22:28
ADR		addressing mode		30:31

Instruction Set Reference
-------------------------

Instruction Operands
--------------------

R	register operand
I	immediate operand following opcode
V	immediate value packed into opcode
A	memory address formed after one of the addressing modes

SYS-UNIT		0x00
--------

HLT			0x00
- halt system until interrupt is received
RST			0x01
- reset system
WFE	RI1		0x02
- wait for event on wait channel
SEV	RI1		0x03
- signal event on wait channel
CLI			0x04
- disable all interrupts
STI	(RI1)		0x05
- enable interrupts, optionally set interrupt mask
INT	RI1	     	0x06
- raise software interrupt

LOGIC-UNIT		0x01
----------

NOT	RI1, R2		0x00		r2 = ~ri1;
- reverse all bits in RI1
AND	RI1, R2		0x01		r2 = ri1 & r2;
- compute logical AND of RI1 and R2
IOR	RI1, R2		0x02		r2 = ri1 | r2;
- compute logical inclusive OR of RI1 and R2
XOR	RI1, R2		0x03		r2 = ri1 ^ r2;

SHIFT-UNIT		0x02
----------

SHL	RV1, R2		0x00		r2 = r2 << ri1;
- bitwise left shift
SHR	RV1, R2		0x01		r2 = r2 >> ri1;
- bitwise [logical] right shift
SAR	RV1, R2		0x02		r2 = r2 >>> ri1;
- arithmetic right shift (fill with sign-bit)
ROL	RV1, R2		0x04		r2 = rol(r2, rv1);
- rotate R2 left by RV1 bits
ROR	RV1, R2		0x0R		r2 = ror(r2, rv1);
- rotate R2 right by RV1 bits

Optional Instructions
---------------------

SLA	V, R1, R2	0x08		r2 = r2 + (r1 << v)
- shift R1 left by V bytes and add to R2
SRA	V, R1, R2	0x09		r2 = r2 + (r1 >> v)
- shift R1 right by V bytes and add to R2; perform arithmetic shift
SLM	V, R1, R2	0x0a		r2 = r2 & (r1 << v);
- shift R1 left and mask R2 by the result
SRM	V, R1, R2	0x0b		r2 = r2 & (r1 >> v)
- shift R1 right and mask R2 by the result; perform arithmetic shift

ADDER-UNIT		0x03
----------

INC	R1		0x00		r1++;
- increment R1 by one
DEC	R1		0x01		r1--;
- decrement R1 by one
ADD	RI1, R2		0x02		r2 = r2 + ri1;
- add RI1 to R2
ADC	RI1, R2		0x03		r2 = r2 + ri1; set CF in MSW
- add RI1 to R2 with carry
SUB	RI1, R2		0x04		r2 = r2 - ri1;
- subtract RI1 from R2
SBC	RI1, R2		0x05		r2 = r2 - ri1; set CF in MSW
- subtract RI1 from R2 with borrow
CMP	RI1, R2		0x06		do R2 - RI1 and set result flags
- compare RI1 and R2

MULTI-UNIT		0x04
----------

MUL	RI1, R2		0x00		r2 = r2 * ri1;
- multiply R2 by RI1
DIV	RI1, R2		0x01		r2 = r2 / ri1;
- divide R2 by RI1
REM	RI1, R2		0x02		r2 = r2 & ri1;
- compute remainder of r2 / ri1
RPC			0x03		r2 = rpc(ri1);
- compute inverse reciprocal rp = 1 / ri1 so that D * rp ~= D / ri1
MLH	RI1, R2		0x04		r2 = (r2 * ri1) >> 32
- multiply R2 by RI1, return high result word

BIT-UNIT		0x05
--------

SEX	RI1, R2		0x00		r2 = sex(ri1);
- sign-extend RI1 into R2
ZEX	RI1, R2		0x01		r2 = zex(ri1);
- zero-extend RI1 into R2
NEG	RI1, R2		0x02		r2 = -ri1;
- compute arithmetic negation of RI1 into R2
SWP	RI1, R2		0x03		r2 = bswap(ri1);
- swap bytes from RI1 into R2

Optional Instructions
---------------------

PAR	RI1, R2		0x04		r2 = par(ri1);
- compute byte parity of RI1 into R2
CLZ	RI1, R2		0x05		r2 = clz(ri1);
- count number of leading 0-bits in RI1 into R2
HAM	RI1, R2		0x06		r2 = ham(ri1);
- count number of 1-bits (Hamming weight / bit population) into R2
BCD	RI1, R2		0x08		r2 = bcd(ri1);
- encode RI1 to binary-coded decimal
BDD	RI1, R2		0x09		r2 = bdd(ri1);
- decode RI1 from binary-coded decimal
CRC	RI1, R2		0x0a		r2 = ip4chk16(ri1) or r2 = ecc32(ri1)
- count IPv4 or ECC checksum of RI1
HSH	RI1, R2	    	0x0b		r2 = hsh(ri1);
- compute hash-value for RI1
HUN	RI1, R2		0x0c		r2 = hun(ri1);
- compute reverse hash-value (of HSH) for RI1

MEM-UNIT		0x06
--------

LEA	A, R2		0x00		r2 = lea(a)
- compute effective address A into R2
LDR	RA1, R2		0x01		r2 = *ra1;
- load register or memory value RA1 into R2
STR	RI1, A		0x02		*a = ri1;
- store RI1 into address A in memory
IPG	RA1		0x03		ipg(ra1);
- invalidate TLB-entry for page of RA1
CLD	RA1		0x04		cld(ra1);
- clear cacheline-dirty bit for RA1
CPF	RA1		0x05		cpf(ra1);
- prefetch cacheline of RA1 into L1 cache
CFL	RA1		0x06		cfl(ra1);
- flush cacheline of RA1 into main memory
BAR			0x08		bar();
- full memory barrier
BRD			0x09		brd();
- memory read barrier
BWR			0x0a		bwr();
- memory write barrier
CLDxx	RA1, R2		0x0c		cldxx(ra1, r2);
- conditional load based on MSW-flags
CSTxx	RI1, A2		0x0d		cstxx(ri1, a2);
- conditional store based on MSW-flags
LDN	RA1, R2		0x0e		r2 = *ra1; bypass cache memory
- non-temporal load operation
STN	RI1, A2		0x0f		*a2 = ri1; bypass cache memory
- non-temporal store operation

Conditions for CLD and CST
--------------------------

Code	MSW-Bits	Description
----	--------	-----------
EQ	ZF		equal
NE	!ZF		not equal
LT	!ZF && LT	less than
LO	!CF    		lower (unsigned < 0)
LE	ZF || LT	less than or equal
LS	!CF || ZF	lower or same (unsigned <=)
GT	!ZF && !LT	greater than
HI	CF && !ZF	higher (unsigned > 0)
GE	ZF || !LT	greater than or equal
HS	CF   		higher or same (unsigned >=)
CF	CF		carry set
NC	!CF		carry not set
OF	OF		overflow set
NO	!OF		overflow not set

STK-UNIT		0x07
--------

PSH	RI1		0x00		*--%sp = ri1;
- push value on stack
POP	R1		0x01		r1 = *sp++;
PSM	V1, V2		0x02		psm(rlo, rhi)
- push registers V1..V2 to stack
  - lowest 7 bits of val-member are R1, next-lowest 7 bits R2
POM	V1, V2	     	0x03	    	pom(rlo, rhi)
- pop registers V1..V2 from stack

ATOM-UNIT		0x08
---------

LNK	A1, R2		0x00		lnk(a1, r2);
- load-linked; load memory value and clear cacheline dirty-bit
STC	RI1, A2		0x01		stc(ri1, a2);
- store conditional; store if cacheline dirty-bit not set
BTC	RI1, A2		0x02		btc(a2, ri1);
- clear bit RI1 in A2 atomically; return old value in CF
BTS	RI1, A2		0x03		bts(a2, ri1);
- set bit RI1 in A2 atomically; return old value in CF
XADD	RI1, A2		0x04		(tmp = *a2, *a2 += ri1, tmp)
- fetch A2 and add RI1 to the memory value
XINC	R1, A2		0x05		(tmp = *a2, *a2++, tmp)
- fetch A2 and increment the memory value by one
XDEC	R1, A2		0x06		(tmp = *a2, *a2--, tmp)
- fetch A2 and increment the memory value by one
CAS	R1, R2, I	0x07		(tmp = *i, if (tmp == r1) { *i = r2 }, tmp)
- compare *i with R1 and swap with R2 if equal; CF -> success, !CF -> failure
CAS2	R1, R2, I	0x08
- like CAS but dual-word/pointer version

FLOW-UNIT		0x09
---------

JMP	A		0x00		branch to *a unconditionally
- branch to address A unconditionally
JMR	RI1		0x01		branch to pc[ri1]
BEQ	A		0x02		branch if equal/zero (ZF)
BZ	A		0x02		same as BEQ
BNE	A		0x03		branch if not equal (!ZF)
BNZ	A		0x03		same as BNE
BLT	A		0x04		branch if less (!ZF && LT)
BGE	A		0x05		branch if greater or equal (ZF || !LT)
BLE	A		0x06		branch if less or equal (ZF || LT)
BGT	A		0x07		branch if greater (!ZF && !LT)
BCF	A		0x08		branch if carry set (CF)
BNC	A		0x09		branch if carry clea (!CF)
BOF	A		0x0a		branch if overflow set (OF)
BNO	A		0x0b		branch if overflow clear (!OF)

SUBR-UNIT		0x0a
---------

BEG	I1

BEG	0x00	I1   		------	---	subroutine prologue
FIN	0x01	RI1		-I----	---	subroutine epilogue; set stack
CSR	0x02	A1		-I----	---	call subroutine
RET	0x03	RI1		-I----	---	return from subroutine
SYS	0x04	RI1, A		-I----	---	enter system call
SRT	0x05	RI1		-I----	---	return from system call
IRT	0x06	RI1		-I----	---	return from interrupt function
----    0x07
THR	0x08	RI1, A		-I----	---	launch a thread
THX	0x09	RI1		-I----	---	terminate a thread
THW	0x0a	RI1		-I----	---	wait for a thread
THY	0x0b	RI1		-I----	---	yield processor (suspend thread)
THC	0x0c	RI1		-I----	---	configure thread

IO-UNIT		0x0b
-------
IOC	0x00	RI1, R2		------	---	I/O command
IRD	0x01	RI1, R2		------	---	I/O read operation
IWR	0x02	RI1, R2		------	---	I/O write operation
ILD	0x03	RI1, R2		------	---	load I/O register
IST	0x04	RI1, A		------	---	store I/O register

